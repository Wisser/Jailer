/*
 * ModelTree.java
 *
 * Created on 12. November 2007, 15:02
 */

package org.jailer.ui;

import java.awt.Color;
import java.awt.Component;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import javax.swing.DefaultListModel;
import javax.swing.JTree;
import javax.swing.ListModel;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.MutableTreeNode;
import javax.swing.tree.TreeCellRenderer;
import javax.swing.tree.TreeModel;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;
import javax.swing.tree.TreeSelectionModel;

import org.jailer.datamodel.Association;
import org.jailer.datamodel.DataModel;
import org.jailer.datamodel.ModelElement;
import org.jailer.datamodel.Table;

/**
 * 
 * @author wisser
 */
public class ModelEditor extends javax.swing.JPanel {

	/** Creates new form ModelTree */
	public ModelEditor() {
		try {
			dataModel = new DataModel(null, null);
			subject = dataModel.getTable("LINE");
		} catch (Exception e) {
			throw new RuntimeException(e);
		}

		initComponents();
		tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
		tree.setExpandsSelectedPaths(true);
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	// <editor-fold defaultstate="collapsed" desc=" Erzeugter Quelltext
    // <editor-fold defaultstate="collapsed" desc=" Erzeugter Quelltext ">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        inspectorHolder = new javax.swing.JPanel();
        jPanel1 = new javax.swing.JPanel();
        jButton1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        legende = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        dependsOn = new javax.swing.JLabel();
        hasDependent = new javax.swing.JLabel();
        associatedWith = new javax.swing.JLabel();
        ignored = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        tree = new javax.swing.JTree();

        setLayout(new java.awt.GridBagLayout());

        inspectorHolder.setLayout(new javax.swing.BoxLayout(inspectorHolder, javax.swing.BoxLayout.X_AXIS));

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weighty = 1.0;
        add(inspectorHolder, gridBagConstraints);

        jButton1.setText("Save");
        jPanel1.add(jButton1);

        jButton2.setText("Cancel");
        jPanel1.add(jButton2);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        add(jPanel1, gridBagConstraints);

        legende.setLayout(new javax.swing.BoxLayout(legende, javax.swing.BoxLayout.Y_AXIS));

        jLabel1.setFont(new java.awt.Font("Dialog", 0, 12));
        jLabel1.setText("Legende:");
        legende.add(jLabel1);

        dependsOn.setFont(new java.awt.Font("Dialog", 0, 12));
        dependsOn.setForeground(new java.awt.Color(153, 0, 0));
        dependsOn.setText("   depends on");
        legende.add(dependsOn);

        hasDependent.setFont(new java.awt.Font("Dialog", 0, 12));
        hasDependent.setForeground(new java.awt.Color(0, 0, 204));
        hasDependent.setText("   has dependent");
        legende.add(hasDependent);

        associatedWith.setFont(new java.awt.Font("Dialog", 0, 12));
        associatedWith.setForeground(new java.awt.Color(0, 153, 51));
        associatedWith.setText("   associated with");
        legende.add(associatedWith);

        ignored.setFont(new java.awt.Font("Dialog", 0, 12));
        ignored.setForeground(new java.awt.Color(153, 153, 153));
        ignored.setText("   ignored");
        legende.add(ignored);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        add(legende, gridBagConstraints);

        jScrollPane1.setAutoscrolls(true);
        tree.setCellRenderer(getTreeCellRenderer());
        tree.setModel(getModel());
        tree.addTreeSelectionListener(new javax.swing.event.TreeSelectionListener() {
            public void valueChanged(javax.swing.event.TreeSelectionEvent evt) {
                treeValueChanged(evt);
            }
        });

        jScrollPane1.setViewportView(tree);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridheight = 3;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        add(jScrollPane1, gridBagConstraints);

    }// </editor-fold>//GEN-END:initComponents

    private void treeValueChanged(javax.swing.event.TreeSelectionEvent evt) {//GEN-FIRST:event_treeValueChanged
    	if (evt.getNewLeadSelectionPath() != null) {
	    	Object selection = ((DefaultMutableTreeNode) evt.getNewLeadSelectionPath().getLastPathComponent()).getUserObject();
	    	if (selection instanceof Association) {
	    		jumpTo(((Association) selection).destination);
	    	}
	    	if (selection instanceof Table) {
	    		jumpTo(subject);
	    	}
    	}
    }//GEN-LAST:event_treeValueChanged

	private void jumpTo(Table table) {
		DefaultMutableTreeNode toSelect = (DefaultMutableTreeNode) treeModel.getRoot();
		for (DefaultMutableTreeNode n: treeNodes) {
			if (!n.isLeaf()) {
				if (((Association) n.getUserObject()).destination.equals(table)) {
					toSelect = n;
					break;
				}
			}
		}
		tree.setSelectionPath(new TreePath(toSelect.getPath()));
		tree.expandPath(new TreePath(toSelect.getPath()));
		tree.scrollPathToVisible(new TreePath(toSelect.getPath()));
	}

	private DataModel dataModel;
	private Table subject;
	private Map<Association, Association> representant = new HashMap<Association, Association>();
	private Map<ModelElement, DefaultMutableTreeNode> toNode = new HashMap<ModelElement, DefaultMutableTreeNode>();
	private DefaultTreeModel treeModel;
	private Collection<DefaultMutableTreeNode> treeNodes = new ArrayList<DefaultMutableTreeNode>();
	
	private TreeModel getModel() {
		DefaultMutableTreeNode root = new DefaultMutableTreeNode(subject);
		Map<Association, DefaultMutableTreeNode> parent = new HashMap<Association, DefaultMutableTreeNode>();
		List<Association> agenda = new LinkedList<Association>();
		
		toNode.put(subject, root);
		for (Association a: subject.associations) {
			agenda.add(a);
			parent.put(a, root);
		}
		while (!agenda.isEmpty()) {
			Association a = agenda.get(0);
			agenda.remove(0);
			if (toNode.get(a) == null) {
				Association rep = null;
				for (ModelElement cand: toNode.keySet()) {
					if (cand instanceof Association) {
						Association candRep = (Association) cand;
						if (a.getName() == null && candRep.getName() == null
						 && a.source.equals(candRep.source) && a.destination.equals(candRep.destination)) {
							rep = candRep;
							break;
						}
					}
				}
				if (rep != null) {
					representant.put(a, rep);
				} else {
					DefaultMutableTreeNode node = new DefaultMutableTreeNode(a);
					treeNodes.add(node);
					parent.get(a).add(node);
					sort(parent.get(a));
					toNode.put(a, node);
					for (Association nextA: a.destination.associations) {
						if (!parent.containsKey(nextA)) {
							agenda.add(nextA);
							parent.put(nextA, node);
						}
					}
				}
			}
		}
		
		treeModel = new DefaultTreeModel(root);
		return treeModel;
	}

	/**
	 * Sorts children of a tree node.
	 * 
	 * @param node the node
	 */
	private void sort(DefaultMutableTreeNode node) {
		List<DefaultMutableTreeNode> children = new ArrayList<DefaultMutableTreeNode>();
		for (int i = 0; i < node.getChildCount(); ++i) {
			children.add((DefaultMutableTreeNode) node.getChildAt(i));
		}
		Collections.sort(children, new Comparator<DefaultMutableTreeNode>() {
			private int cat(Association a) {
				if (a.isIgnored()) {
					return 0;
				}
				if (a.isInsertDestinationBeforeSource()) {
					return 1;
				}
				if (a.isInsertSourceBeforeDestination()) {
					return 2;
				}
				return 3;
			}
			
			public int compare(DefaultMutableTreeNode o1,
					DefaultMutableTreeNode o2) {
				Association a1 = (Association) o1.getUserObject();
				Association a2 = (Association) o2.getUserObject();
				int cat1 = cat(a1);
				int cat2 = cat(a2);
				if (cat1 == cat2) {
					return a1.destination.getName().compareTo(a2.destination.getName());
				}
				return cat1 - cat2;
			}
		});
		node.removeAllChildren();
		for (MutableTreeNode child: children) {
			node.add(child);
		}
	}

	private TreeCellRenderer getTreeCellRenderer() {
		return new DefaultTreeCellRenderer() {
			public Component getTreeCellRendererComponent(JTree tree,
					Object value, boolean selected, boolean expanded,
					boolean leaf, int row, boolean hasFocus) {
				DefaultMutableTreeNode node = (DefaultMutableTreeNode) value;
				String text = "";
				if (node.getUserObject() instanceof Table) {
					text = ((Table) node.getUserObject()).getName();
					setTextSelectionColor(Color.BLACK);
					setTextNonSelectionColor(Color.BLACK);
				} else if (node.getUserObject() instanceof Association) {
					Association association = (Association) node.getUserObject();
					text = association.destination.getName();
					if (association.isIgnored()) {
						setTextSelectionColor(ignored.getForeground());
						setTextNonSelectionColor(ignored.getForeground());
					} else if (association.isInsertDestinationBeforeSource()) {
						setTextSelectionColor(dependsOn.getForeground());
						setTextNonSelectionColor(dependsOn.getForeground());
					} else if (association.isInsertSourceBeforeDestination()) {
						setTextSelectionColor(hasDependent.getForeground());
						setTextNonSelectionColor(hasDependent.getForeground());
					} else {
						setTextSelectionColor(associatedWith.getForeground());
						setTextNonSelectionColor(associatedWith.getForeground());
					}
				}
				return super.getTreeCellRendererComponent(tree, text, selected, expanded, leaf, row, hasFocus);
			}
		};
	}

	private ListModel getTablesList() {
    	DefaultListModel defaultListModel = new DefaultListModel();
    	for (Table table: dataModel.getTables()) {
    		defaultListModel.addElement(table.getName());
    	}
    	return defaultListModel;
    }
        
    // Variablendeklaration - nicht modifizieren//GEN-BEGIN:variables
    private javax.swing.JLabel associatedWith;
    private javax.swing.JLabel dependsOn;
    private javax.swing.JLabel hasDependent;
    private javax.swing.JLabel ignored;
    private javax.swing.JPanel inspectorHolder;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JPanel legende;
    private javax.swing.JTree tree;
    // Ende der Variablendeklaration//GEN-END:variables

}
