/*
 * ModelTree.java
 *
 * Created on 12. November 2007, 15:02
 */

package org.jailer.ui;

import java.awt.Color;
import java.awt.Component;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import javax.swing.DefaultListModel;
import javax.swing.JTree;
import javax.swing.ListModel;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.MutableTreeNode;
import javax.swing.tree.TreeCellRenderer;
import javax.swing.tree.TreeModel;
import javax.swing.tree.TreePath;
import javax.swing.tree.TreeSelectionModel;

import org.jailer.datamodel.Association;
import org.jailer.datamodel.DataModel;
import org.jailer.datamodel.ModelElement;
import org.jailer.datamodel.Table;
import org.jailer.util.SqlUtil;

/**
 * 
 * @author wisser
 */
public class ExtractionModelEditor extends javax.swing.JPanel {

	private RestrictionEditor restrictionEditor;
	
	/** Creates new form ModelTree */
	public ExtractionModelEditor() {
		try {
			dataModel = new DataModel(null, null);
			subject = dataModel.getTable("LINE");
		} catch (Exception e) {
			throw new RuntimeException(e);
		}

		initComponents();
		tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
		tree.setExpandsSelectedPaths(true);
		restrictionEditor = new RestrictionEditor();
		inspectorHolder.add(restrictionEditor);
		restrictionEditor.apply.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				onApply();
			}
		});
		restrictionEditor.ignore.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				onApply();
			}
		});
		restrictionEditor.jump.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				onJump();
			}
		});
		initRestrictionEditor(null, null);
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	// <editor-fold defaultstate="collapsed" desc=" Erzeugter Quelltext
    // <editor-fold defaultstate="collapsed" desc=" Erzeugter Quelltext ">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        inspectorHolder = new javax.swing.JPanel();
        jPanel1 = new javax.swing.JPanel();
        jButton1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        legende = new javax.swing.JPanel();
        dependsOn = new javax.swing.JLabel();
        hasDependent = new javax.swing.JLabel();
        associatedWith = new javax.swing.JLabel();
        ignored = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        tree = new javax.swing.JTree();

        setLayout(new java.awt.GridBagLayout());

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTH;
        gridBagConstraints.weighty = 1.0;
        add(inspectorHolder, gridBagConstraints);

        jButton1.setText("Save");
        jPanel1.add(jButton1);

        jButton2.setText("Cancel");
        jPanel1.add(jButton2);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        add(jPanel1, gridBagConstraints);

        legende.setLayout(new java.awt.GridBagLayout());

        dependsOn.setFont(new java.awt.Font("Dialog", 0, 12));
        dependsOn.setForeground(new java.awt.Color(153, 0, 0));
        dependsOn.setText("   depends on");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.weightx = 1.0;
        legende.add(dependsOn, gridBagConstraints);

        hasDependent.setFont(new java.awt.Font("Dialog", 0, 12));
        hasDependent.setForeground(new java.awt.Color(0, 0, 204));
        hasDependent.setText("   has dependent");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.weightx = 1.0;
        legende.add(hasDependent, gridBagConstraints);

        associatedWith.setFont(new java.awt.Font("Dialog", 0, 12));
        associatedWith.setForeground(new java.awt.Color(0, 153, 51));
        associatedWith.setText("   associated with");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.weightx = 1.0;
        legende.add(associatedWith, gridBagConstraints);

        ignored.setFont(new java.awt.Font("Dialog", 0, 12));
        ignored.setForeground(new java.awt.Color(153, 153, 153));
        ignored.setText("   ignored");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.weightx = 1.0;
        legende.add(ignored, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 6);
        add(legende, gridBagConstraints);

        jScrollPane1.setAutoscrolls(true);
        tree.setCellRenderer(getTreeCellRenderer());
        tree.setModel(getModel());
        tree.addTreeSelectionListener(new javax.swing.event.TreeSelectionListener() {
            public void valueChanged(javax.swing.event.TreeSelectionEvent evt) {
                treeValueChanged(evt);
            }
        });

        jScrollPane1.setViewportView(tree);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridheight = 3;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        add(jScrollPane1, gridBagConstraints);

    }// </editor-fold>//GEN-END:initComponents

    private void treeValueChanged(javax.swing.event.TreeSelectionEvent evt) {//GEN-FIRST:event_treeValueChanged
    	if (evt.getNewLeadSelectionPath() != null) {
    		DefaultMutableTreeNode node = ((DefaultMutableTreeNode) evt.getNewLeadSelectionPath().getLastPathComponent());
			Object selection = node.getUserObject();
	    	if (selection instanceof Association) {
	    		initRestrictionEditor((Association) selection, node);
	    	}
	    	if (selection instanceof Table) {
	    		initRestrictionEditor(null, null);
	    	}
    	}
    }//GEN-LAST:event_treeValueChanged

    private Association currentAssociation;
    
    /**
     * Initializes the restriction model.
     * 
     * @param association the association on which a restriction can be edited
     * @param node selected tree node
     */
    private void initRestrictionEditor(Association association, DefaultMutableTreeNode node) {
    	currentAssociation = association;
		if (association == null) {
			restrictionEditor.setVisible(false);
		} else {
			DefaultMutableTreeNode mainNode = (DefaultMutableTreeNode) treeModel.getRoot();
			for (DefaultMutableTreeNode n: treeNodes) {
				if (!n.isLeaf()) {
					if (((Association) n.getUserObject()).equals(association)) {
						mainNode = n;
						break;
					}
				}
			}
			if (mainNode != null && !node.equals(mainNode)) {
				restrictionEditor.jump.setEnabled(true);
			} else {
				restrictionEditor.jump.setEnabled(false);
			}
			restrictionEditor.setVisible(true);

			String type = "Association ";
			boolean editable = true;
			if (association.isInsertDestinationBeforeSource()) {
				type = "Dependency ";
				editable = false;
			} else if (association.isInsertSourceBeforeDestination()) {
				type = "Inverse dependency ";
			}
			restrictionEditor.source.setText(association.source.getName());
			restrictionEditor.destination.setText(association.destination.getName());
			restrictionEditor.cardinality.setText(association.getCardinality() == null? "unknown" : association.getCardinality().toString());
			restrictionEditor.type.setText(type);
			restrictionEditor.joinCondition.setText(association.getUnrestrictedJoinCondition());
			restrictionEditor.restriction.setText(association.getRestrictionCondition());
			restrictionEditor.ignore.getModel().setPressed(association.isIgnored());
			restrictionEditor.restriction.setEnabled(editable);
			restrictionEditor.ignore.setEnabled(editable);
			restrictionEditor.apply.setEnabled(editable);
			String joinCondition = association.getUnrestrictedJoinCondition();
			if (association.reversed) {
				joinCondition = SqlUtil.reversRestrictionCondition(joinCondition);
			}
			boolean singleCondition = true;
			for (Association represented: representant.keySet()) {
				if (association.equals(representant.get(represented))) {
					String jc = represented.getUnrestrictedJoinCondition();
					if (represented.reversed) {
						jc = SqlUtil.reversRestrictionCondition(jc);
					}
					if (singleCondition) {
						joinCondition = "(" + joinCondition + ")";
					}
					singleCondition = false;
					joinCondition += "\nor\n(" + jc + ")";
				}
			}
			restrictionEditor.joinCondition.setText(joinCondition);
		}
	}

	private void onJump() {
    	if (tree.getLeadSelectionPath() != null) {
    		Object selection = ((DefaultMutableTreeNode) tree.getLeadSelectionPath().getLastPathComponent()).getUserObject();
	    	if (selection instanceof Association) {
	    		jumpTo(((Association) selection).destination);
	    	}
	    	if (selection instanceof Table) {
	    		jumpTo(subject);
	    	}
    	}
    }

    private void onApply() {
    	
    }
    
	private void jumpTo(Table table) {
		DefaultMutableTreeNode toSelect = (DefaultMutableTreeNode) treeModel.getRoot();
		for (DefaultMutableTreeNode n: treeNodes) {
			if (!n.isLeaf()) {
				if (((Association) n.getUserObject()).destination.equals(table)) {
					toSelect = n;
					break;
				}
			}
		}
		tree.setSelectionPath(new TreePath(toSelect.getPath()));
		tree.expandPath(new TreePath(toSelect.getPath()));
		tree.scrollPathToVisible(new TreePath(toSelect.getPath()));
	}

	private DataModel dataModel;
	private Table subject;
	private Map<Association, Association> representant = new HashMap<Association, Association>();
	private Map<ModelElement, DefaultMutableTreeNode> toNode = new HashMap<ModelElement, DefaultMutableTreeNode>();
	private DefaultTreeModel treeModel;
	private Collection<DefaultMutableTreeNode> treeNodes = new ArrayList<DefaultMutableTreeNode>();
	
	private TreeModel getModel() {
		DefaultMutableTreeNode root = new DefaultMutableTreeNode(subject);
		Map<Association, DefaultMutableTreeNode> parent = new HashMap<Association, DefaultMutableTreeNode>();
		List<Association> agenda = new LinkedList<Association>();
		
		toNode.put(subject, root);
		for (Association a: subject.associations) {
			agenda.add(a);
			parent.put(a, root);
		}
		while (!agenda.isEmpty()) {
			Association a = agenda.get(0);
			agenda.remove(0);
			if (toNode.get(a) == null) {
				Association rep = null;
				for (ModelElement cand: toNode.keySet()) {
					if (cand instanceof Association) {
						Association candRep = (Association) cand;
						if ((a.getName() == null || candRep.getName() == null)
						 && a.source.equals(candRep.source) && a.destination.equals(candRep.destination)) {
							rep = candRep;
							break;
						}
					}
				}
				if (rep != null) {
					representant.put(a, rep);
				} else {
					DefaultMutableTreeNode node = new DefaultMutableTreeNode(a);
					treeNodes.add(node);
					parent.get(a).add(node);
					sort(parent.get(a));
					toNode.put(a, node);
					for (Association nextA: a.destination.associations) {
						if (!parent.containsKey(nextA)) {
							agenda.add(nextA);
							parent.put(nextA, node);
						}
					}
				}
			}
		}
		treeModel = new DefaultTreeModel(root);
		return treeModel;
	}

	/**
	 * Sorts children of a tree node.
	 * 
	 * @param node the node
	 */
	private void sort(DefaultMutableTreeNode node) {
		List<DefaultMutableTreeNode> children = new ArrayList<DefaultMutableTreeNode>();
		for (int i = 0; i < node.getChildCount(); ++i) {
			children.add((DefaultMutableTreeNode) node.getChildAt(i));
		}
		Collections.sort(children, new Comparator<DefaultMutableTreeNode>() {
			private int cat(Association a) {
				if (a.isIgnored()) {
					return 0;
				}
				if (a.isInsertDestinationBeforeSource()) {
					return 1;
				}
				if (a.isInsertSourceBeforeDestination()) {
					return 2;
				}
				return 3;
			}
			
			public int compare(DefaultMutableTreeNode o1,
					DefaultMutableTreeNode o2) {
				Association a1 = (Association) o1.getUserObject();
				Association a2 = (Association) o2.getUserObject();
				int cat1 = cat(a1);
				int cat2 = cat(a2);
				if (cat1 == cat2) {
					return a1.destination.getName().compareTo(a2.destination.getName());
				}
				return cat1 - cat2;
			}
		});
		node.removeAllChildren();
		for (MutableTreeNode child: children) {
			node.add(child);
		}
	}

	private TreeCellRenderer getTreeCellRenderer() {
		return new DefaultTreeCellRenderer() {
			public Component getTreeCellRendererComponent(JTree tree,
					Object value, boolean selected, boolean expanded,
					boolean leaf, int row, boolean hasFocus) {
				DefaultMutableTreeNode node = (DefaultMutableTreeNode) value;
				String text = "";
				if (node.getUserObject() instanceof Table) {
					text = ((Table) node.getUserObject()).getName();
					setTextSelectionColor(Color.BLACK);
					setTextNonSelectionColor(Color.BLACK);
				} else if (node.getUserObject() instanceof Association) {
					Association association = (Association) node.getUserObject();
					text = association.destination.getName();
					if (association.isIgnored()) {
						setTextSelectionColor(ignored.getForeground());
						setTextNonSelectionColor(ignored.getForeground());
					} else if (association.isInsertDestinationBeforeSource()) {
						setTextSelectionColor(dependsOn.getForeground());
						setTextNonSelectionColor(dependsOn.getForeground());
					} else if (association.isInsertSourceBeforeDestination()) {
						setTextSelectionColor(hasDependent.getForeground());
						setTextNonSelectionColor(hasDependent.getForeground());
					} else {
						setTextSelectionColor(associatedWith.getForeground());
						setTextNonSelectionColor(associatedWith.getForeground());
					}
				}
				return super.getTreeCellRendererComponent(tree, text, selected, expanded, leaf, row, hasFocus);
			}
		};
	}

	private ListModel getTablesList() {
    	DefaultListModel defaultListModel = new DefaultListModel();
    	for (Table table: dataModel.getTables()) {
    		defaultListModel.addElement(table.getName());
    	}
    	return defaultListModel;
    }
        
    // Variablendeklaration - nicht modifizieren//GEN-BEGIN:variables
    private javax.swing.JLabel associatedWith;
    private javax.swing.JLabel dependsOn;
    private javax.swing.JLabel hasDependent;
    private javax.swing.JLabel ignored;
    private javax.swing.JPanel inspectorHolder;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JPanel legende;
    private javax.swing.JTree tree;
    // Ende der Variablendeklaration//GEN-END:variables

}
